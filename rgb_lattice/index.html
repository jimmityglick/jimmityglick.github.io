"use client";

import React, { useEffect, useMemo, useRef, useState, useImperativeHandle } from "react";

// =====================================================
// PURE SVG + INTERACTION (NO three.js / NO @react-three/fiber)
// =====================================================

// =========================================
// Shared Helpers & Math
// =========================================

function assert(cond, msg) {
  if (!cond) throw new Error(msg);
}

function clamp(v, lo, hi) {
  return Math.max(lo, Math.min(hi, v));
}

function rotateZ([x, y, z], a) {
  const c = Math.cos(a);
  const s = Math.sin(a);
  return [x * c - y * s, x * s + y * c, z];
}

function rotateY([x, y, z], a) {
  const c = Math.cos(a);
  const s = Math.sin(a);
  return [x * c + z * s, y, -x * s + z * c];
}

function rotateX([x, y, z], a) {
  const c = Math.cos(a);
  const s = Math.sin(a);
  return [x, y * c - z * s, y * s + z * c];
}

function projectIso([x, y, z], w, h, zoom) {
  const base = Math.min(w, h) * 0.22;
  const scale = base * zoom;
  const px = (x + 0.85 * z) * scale;
  const py = (-y + 0.55 * z) * scale;
  return [w / 2 + px, h / 2 + py, z];
}

// Vector math helpers for the spiral basis
function crossProduct(a, b) {
  return [
    a[1] * b[2] - a[2] * b[1],
    a[2] * b[0] - a[0] * b[2],
    a[0] * b[1] - a[1] * b[0]
  ];
}

function normalize(v) {
  const mag = Math.hypot(v[0], v[1], v[2]);
  return mag === 0 ? [0, 0, 0] : [v[0] / mag, v[1] / mag, v[2] / mag];
}

function useRaf(callback) {
  const cbRef = useRef(callback);
  cbRef.current = callback;

  useEffect(() => {
    let raf = 0;
    let last = performance.now();

    const tick = (t) => {
      const dt = Math.max(0, (t - last) / 1000);
      last = t;
      cbRef.current(dt, t / 1000);
      raf = requestAnimationFrame(tick);
    };

    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, []);
}

function applyDragRotation({ theta, phi }, dx, dy, sensitivity) {
  // Clamping is removed to allow free infinite rotation on all axes
  const nextTheta = theta - dx * sensitivity;
  const nextPhi = phi - dy * sensitivity;
  return { theta: nextTheta, phi: nextPhi };
}

function textColorForFill(fill) {
  const hex = fill.replace("#", "");
  const r = parseInt(hex.slice(0, 2), 16);
  const g = parseInt(hex.slice(2, 4), 16);
  const b = parseInt(hex.slice(4, 6), 16);
  const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
  return luminance > 160 ? "#000000" : "#ffffff";
}

function rgbCss(r, g, b) {
  const to255 = (v) => Math.round(v * 255);
  return `rgb(${to255(r)}, ${to255(g)}, ${to255(b)})`;
}

// Axis-Aligned Bounding Box (AABB) Ray Intersection
function intersectCube(origin, dir, size) {
  let tmin = -Infinity;
  let tmax = Infinity;

  for (let i = 0; i < 3; i++) {
    if (Math.abs(dir[i]) < 1e-6) {
      if (origin[i] < -size || origin[i] > size) return null;
    } else {
      let t1 = (-size - origin[i]) / dir[i];
      let t2 = (size - origin[i]) / dir[i];
      if (t1 > t2) { let temp = t1; t1 = t2; t2 = temp; }
      tmin = Math.max(tmin, t1);
      tmax = Math.min(tmax, t2);
    }
  }
  if (tmax >= tmin && tmax > 0) {
    return { start: Math.max(0, tmin), end: tmax };
  }
  return null;
}

// =========================================
// 1) RGB Boolean Lattice (Binary: 0 / 1)
// =========================================

const colorMapBinary = {
  "000": "#000000",
  "100": "#ff1a1a",
  "010": "#00d26a",
  "001": "#2a6bff",
  "110": "#ffe600",
  "101": "#ff2bd6",
  "011": "#00e7ff",
  "111": "#ffffff",
};

const labelMapBinary = {
  "000": "∅",
  "100": "R",
  "010": "G",
  "001": "B",
  "110": "R+G",
  "101": "R+B",
  "011": "G+B",
  "111": "R+G+B",
};

function buildBinaryGraph3D() {
  const nodes = [];
  const edges = [];
  const scale = 1.35;
  const levels = [0, 1];

  for (const r of levels) {
    for (const g of levels) {
      for (const b of levels) {
        const id = `${r}${g}${b}`;
        const x = (r === 0 ? -1 : 1) * scale;
        const y = (g === 0 ? -1 : 1) * scale;
        const z = (b === 0 ? -1 : 1) * scale;
        nodes.push({ id, r, g, b, pos: [x, y, z], sum: r + g + b, label: labelMapBinary[id] });
      }
    }
  }

  // Cover relations (Hamming distance of 1, increasing)
  for (const a of nodes) {
    for (const b of nodes) {
      const dr = b.r - a.r;
      const dg = b.g - a.g;
      const db = b.b - a.b;
      if (dr >= 0 && dg >= 0 && db >= 0 && dr + dg + db === 1) {
        edges.push([a.id, b.id]);
      }
    }
  }

  assert(nodes.length === 8, "Binary nodes must be 8");
  assert(edges.length === 12, "Binary edges must be 12");
  return { nodes, edges };
}

const BINARY_3D = buildBinaryGraph3D();

// =========================================
// 2) RGB Ternary Lattice (0 / 0.5 / 1)
// =========================================

function toCenteredCoord(v) {
  if (v === 0) return -1;
  if (v === 0.5) return 0;
  return 1;
}

function buildTernaryGraph() {
  const nodes = [];
  const edges = [];
  const scale = 1.35;
  const levels = [0, 0.5, 1];

  for (const r of levels) {
    for (const g of levels) {
      for (const b of levels) {
        const id = `${r}-${g}-${b}`;
        const x = toCenteredCoord(r) * scale;
        const y = toCenteredCoord(g) * scale;
        const z = toCenteredCoord(b) * scale;
        nodes.push({ id, r, g, b, pos: [x, y, z], sum: r + g + b });
      }
    }
  }

  for (const a of nodes) {
    for (const b of nodes) {
      const dr = b.r - a.r;
      const dg = b.g - a.g;
      const db = b.b - a.b;
      const diffs = [dr, dg, db];
      const positive = diffs.filter((d) => d === 0.5);
      const zero = diffs.filter((d) => d === 0);
      if (positive.length === 1 && zero.length === 2) edges.push([a.id, b.id]);
    }
  }

  assert(nodes.length === 27, "Ternary nodes must be 27");
  return { nodes, edges };
}

const TERNARY_3D = buildTernaryGraph();

// =========================================
// 3) Interactive UI Components
// =========================================

const BinaryLatticeProjected = React.forwardRef(({ width = 650, height = 650, autoRotate = {x: false, y: true, z: false}, showNodes = true, showEdges = true }, ref) => {
  const [psi, setPsi] = useState(0);     // Z-axis roll
  const [theta, setTheta] = useState(0); // Y-axis yaw
  const [phi, setPhi] = useState(0.62);  // X-axis pitch
  const [zoom, setZoom] = useState(1.0);
  const [dragging, setDragging] = useState(false);

  const svgRef = useRef(null);
  const dragRef = useRef({ active: false, lastX: 0, lastY: 0, pointerId: null });

  useImperativeHandle(ref, () => ({
    resetView: () => {
      setPsi(0);
      setTheta(0);
      setPhi(0.62);
      setZoom(1.0);
    }
  }));

  const ROT_SENS = 0.008;
  const ZOOM_MIN = 0.6;
  const ZOOM_MAX = 2.2;

  useRaf((dt) => {
    if (!dragging) {
      if (autoRotate.x) setPhi((v) => v + dt * 0.45);
      if (autoRotate.y) setTheta((v) => v + dt * 0.45);
      if (autoRotate.z) setPsi((v) => v + dt * 0.45);
    }
  });

  const onPointerDown = (e) => {
    if (!svgRef.current || (e.button !== undefined && e.button !== 0)) return;
    svgRef.current.setPointerCapture?.(e.pointerId);
    dragRef.current = { active: true, lastX: e.clientX, lastY: e.clientY, pointerId: e.pointerId };
    setDragging(true);
  };

  const onPointerMove = (e) => {
    const d = dragRef.current;
    if (!d.active) return;
    const dx = e.clientX - d.lastX;
    const dy = e.clientY - d.lastY;
    d.lastX = e.clientX;
    d.lastY = e.clientY;

    setTheta((t) => applyDragRotation({ theta: t, phi }, dx, dy, ROT_SENS).theta);
    setPhi((p) => applyDragRotation({ theta, phi: p }, dx, dy, ROT_SENS).phi);
  };

  const endDrag = (e) => {
    if (!dragRef.current.active) return;
    try { svgRef.current?.releasePointerCapture(e.pointerId); } catch {}
    dragRef.current = { active: false, lastX: 0, lastY: 0, pointerId: null };
    setDragging(false);
  };

  useEffect(() => {
    const el = svgRef.current;
    if (!el) return;
    const handleWheel = (e) => {
      e.preventDefault();
      const factor = e.deltaY > 0 ? 0.92 : 1.08;
      setZoom((z) => clamp(z * factor, ZOOM_MIN, ZOOM_MAX));
    };
    el.addEventListener("wheel", handleWheel, { passive: false });
    return () => el.removeEventListener("wheel", handleWheel);
  }, []);

  const { nodes2d, edges2d } = useMemo(() => {
    const pos2dById = {};

    const nodes2d = BINARY_3D.nodes
      .map((n) => {
        let p = rotateZ(n.pos, psi);
        p = rotateY(p, theta);
        p = rotateX(p, phi);
        const [sx, sy, z] = projectIso(p, width, height, zoom);
        pos2dById[n.id] = [sx, sy, z];
        return { ...n, screen: [sx, sy, z] };
      })
      .sort((a, b) => a.screen[2] - b.screen[2]);

    const edges2d = BINARY_3D.edges.map(([a, b]) => ({ a, b, pa: pos2dById[a], pb: pos2dById[b] }));
    return { nodes2d, edges2d };
  }, [psi, theta, phi, zoom, width, height]);

  return (
    <svg
      ref={svgRef}
      width={width}
      height={height}
      className="rounded-2xl shadow-2xl bg-black"
      style={{ touchAction: "none", cursor: dragging ? "grabbing" : "grab" }}
      onPointerDown={onPointerDown}
      onPointerMove={onPointerMove}
      onPointerUp={endDrag}
      onPointerCancel={endDrag}
      onPointerLeave={endDrag}
    >
      {showEdges && edges2d.map((e, i) => (
        <line key={i} x1={e.pa[0]} y1={e.pa[1]} x2={e.pb[0]} y2={e.pb[1]} stroke="#64748b" strokeWidth="2.5" opacity="0.4" />
      ))}

      {showNodes && nodes2d.map((n) => {
        const [x, y, z] = n.screen;
        const fill = colorMapBinary[n.id];
        const tcol = textColorForFill(fill);

        const depth = (z + 2.2) / 4.4;
        const depthBoost = 0.45 + 0.65 * clamp(depth, 0, 1);

        const r = 30.0 * zoom;
        const opacity = (0.75 + 0.25 * depthBoost) * 0.80;

        const isBlackNode = n.id === "000";
        const strokeColor = isBlackNode ? "#ffffff" : "#e2e8f0";
        const strokeWidth = (isBlackNode ? 3 : 2) * zoom;

        return (
          <g key={n.id} opacity={opacity}>
            <circle cx={x} cy={y} r={r} fill={fill} stroke={strokeColor} strokeWidth={strokeWidth} style={{ filter: "drop-shadow(0px 4px 8px rgba(0,0,0,0.5))" }} />
            <text x={x} y={y} textAnchor="middle" dominantBaseline="middle" fontSize={14 * zoom} fontWeight="800" fill={tcol}>
              {n.label}
            </text>
          </g>
        );
      })}

      <text x={18} y={26} fontSize={12} fontWeight={800} fill="#e2e8f0">
        Projected 3D lattice over {"{0, 1}³"}
      </text>
      <text x={18} y={46} fontSize={11} fontWeight={600} fill="#94a3b8">
        Drag to rotate. Wheel to zoom.
      </text>
    </svg>
  );
});

const TernaryLatticeProjected = React.forwardRef(({ width = 650, height = 650, autoRotate = {x: false, y: true, z: false}, showNodes = true, showEdges = true }, ref) => {
  const [psi, setPsi] = useState(0);
  const [theta, setTheta] = useState(0);
  const [phi, setPhi] = useState(0.62);
  const [zoom, setZoom] = useState(1.0);
  const [dragging, setDragging] = useState(false);
  const [, setTick] = useState(0);

  const svgRef = useRef(null);
  const dragRef = useRef({ active: false, startX: 0, startY: 0, lastX: 0, lastY: 0, pointerId: null });
  const activeBalls = useRef([]);

  useImperativeHandle(ref, () => ({
    resetView: () => {
      setPsi(0);
      setTheta(0);
      setPhi(0.62);
      setZoom(1.0);
    }
  }));

  const ROT_SENS = 0.008;
  const ZOOM_MIN = 0.6;
  const ZOOM_MAX = 2.2;

  useRaf((dt) => {
    let needsRender = false;
    
    if (!dragging) {
      if (autoRotate.x) { setPhi((v) => v + dt * 0.45); needsRender = true; }
      if (autoRotate.y) { setTheta((v) => v + dt * 0.45); needsRender = true; }
      if (autoRotate.z) { setPsi((v) => v + dt * 0.45); needsRender = true; }
    }
    
    // Manage active ball lifecycle: Cull them spatially instead of strictly by time
    if (activeBalls.current.length > 0) {
      const now = performance.now();
      activeBalls.current = activeBalls.current.filter((b) => {
        const tProg = (now - b.startTime) / 12000;
        if (tProg <= 1) return true; // Always keep while spiraling inside the cube
        
        // Once in tangent world-space, check its distance from the origin.
        if (b.exitLatched) {
          const overT = tProg - 1;
          const px = b.exitWorldPos[0] + b.exitWorldVel[0] * overT;
          const py = b.exitWorldPos[1] + b.exitWorldVel[1] * overT;
          const pz = b.exitWorldPos[2] + b.exitWorldVel[2] * overT;
          return (px * px + py * py + pz * pz) < 400; 
        }
        
        // Failsafe time limit just in case
        return tProg < 10;
      });
      needsRender = true;
    }

    const isRotating = autoRotate.x || autoRotate.y || autoRotate.z;
    if (needsRender && (!isRotating || dragging)) {
      setTick((t) => t + 1);
    }
  });

  const fireBall = (clientX, clientY) => {
    if (!svgRef.current) return;
    const rect = svgRef.current.getBoundingClientRect();
    const base = Math.min(width, height) * 0.22;
    const scale = base * zoom;

    const cx = clientX - rect.left - width / 2;
    const cy = clientY - rect.top - height / 2;

    // Inverse of projection (normalized to z=0 and z=-1 planes)
    const px = cx / scale;
    const py = cy / scale;
    const originRot = [px, -py, 0];
    const dirRot = [0.85, -0.55, -1]; // Ray points exactly "into" the screen

    // Pull the ray origin far back along the inverted view vector so it strictly starts OUTSIDE the bounding box.
    const pullBack = 5;
    const pulledOriginRot = [
      originRot[0] - dirRot[0] * pullBack,
      originRot[1] - dirRot[1] * pullBack,
      originRot[2] - dirRot[2] * pullBack
    ];

    // Un-rotate the ray back to pure model space: apply inverse rotations in reverse order (X -> Y -> Z)
    let originM = rotateX(pulledOriginRot, -phi);
    originM = rotateY(originM, -theta);
    originM = rotateZ(originM, -psi);

    let dirM = rotateX(dirRot, -phi);
    dirM = rotateY(dirM, -theta);
    dirM = rotateZ(dirM, -psi);

    // Bounding Box intersection against the 1.35 color cube limits
    const hit = intersectCube(originM, dirM, 1.35);
    if (hit) {
      const startP = [
        originM[0] + hit.start * dirM[0],
        originM[1] + hit.start * dirM[1],
        originM[2] + hit.start * dirM[2],
      ];
      const endP = [
        originM[0] + hit.end * dirM[0],
        originM[1] + hit.end * dirM[1],
        originM[2] + hit.end * dirM[2],
      ];

      // Calculate an orthogonal basis (U, V) perpendicular to the direction of travel
      const axisDir = normalize(dirM);
      let up = [0, 1, 0];
      if (Math.abs(axisDir[1]) > 0.99) up = [1, 0, 0]; // Prevent cross-product failure if ray is exactly vertical
      
      const uBasis = normalize(crossProduct(up, axisDir));
      const vBasis = normalize(crossProduct(axisDir, uBasis));

      activeBalls.current.push({
        id: Math.random().toString(),
        startP,
        endP,
        uBasis,
        vBasis,
        startTime: performance.now(),
        exitLatched: false // Track transition state
      });
    }
  };

  const onPointerDown = (e) => {
    if (!svgRef.current || (e.button !== undefined && e.button !== 0)) return;
    svgRef.current.setPointerCapture?.(e.pointerId);
    dragRef.current = { active: true, startX: e.clientX, startY: e.clientY, lastX: e.clientX, lastY: e.clientY, pointerId: e.pointerId };
    setDragging(true);
  };

  const onPointerMove = (e) => {
    const d = dragRef.current;
    if (!d.active) return;
    const dx = e.clientX - d.lastX;
    const dy = e.clientY - d.lastY;
    d.lastX = e.clientX;
    d.lastY = e.clientY;

    setTheta((t) => applyDragRotation({ theta: t, phi }, dx, dy, ROT_SENS).theta);
    setPhi((p) => applyDragRotation({ theta, phi: p }, dx, dy, ROT_SENS).phi);
  };

  const endDrag = (e) => {
    const d = dragRef.current;
    if (!d.active) return;
    try { svgRef.current?.releasePointerCapture(e.pointerId); } catch {}

    // Differentiate between a drag and a pure click
    const dist = Math.hypot(e.clientX - d.startX, e.clientY - d.startY);
    if (dist < 5) {
      fireBall(e.clientX, e.clientY);
    }

    dragRef.current = { active: false, startX: 0, startY: 0, lastX: 0, lastY: 0, pointerId: null };
    setDragging(false);
  };

  useEffect(() => {
    const el = svgRef.current;
    if (!el) return;
    const handleWheel = (e) => {
      e.preventDefault();
      const factor = e.deltaY > 0 ? 0.92 : 1.08;
      setZoom((z) => clamp(z * factor, ZOOM_MIN, ZOOM_MAX));
    };
    el.addEventListener("wheel", handleWheel, { passive: false });
    return () => el.removeEventListener("wheel", handleWheel);
  }, []);

  const { nodes2d, edges2d } = useMemo(() => {
    const pos2dById = {};

    const nodes2d = TERNARY_3D.nodes
      .map((n) => {
        let p = rotateZ(n.pos, psi);
        p = rotateY(p, theta);
        p = rotateX(p, phi);
        const [sx, sy, z] = projectIso(p, width, height, zoom);
        pos2dById[n.id] = [sx, sy, z];
        return { ...n, screen: [sx, sy, z] };
      })
      .sort((a, b) => a.screen[2] - b.screen[2]);

    const edges2d = TERNARY_3D.edges.map(([a, b]) => ({ a, b, pa: pos2dById[a], pb: pos2dById[b] }));
    return { nodes2d, edges2d };
  }, [psi, theta, phi, zoom, width, height]);

  return (
    <svg
      ref={svgRef}
      width={width}
      height={height}
      className="rounded-2xl shadow-2xl bg-black"
      style={{ touchAction: "none", cursor: dragging ? "grabbing" : "grab" }}
      onPointerDown={onPointerDown}
      onPointerMove={onPointerMove}
      onPointerUp={endDrag}
      onPointerCancel={endDrag}
      onPointerLeave={endDrag}
    >
      {showEdges && edges2d.map((e, i) => (
        <line key={i} x1={e.pa[0]} y1={e.pa[1]} x2={e.pb[0]} y2={e.pb[1]} stroke="#94a3b8" strokeWidth="1.5" opacity="0.22" />
      ))}

      {showNodes && nodes2d.map((n) => {
        const [x, y, z] = n.screen;
        const fill = rgbCss(n.r, n.g, n.b);
        const depth = (z + 2.2) / 4.4;
        const depthBoost = 0.45 + 0.65 * clamp(depth, 0, 1);

        const isWhole = n.r % 1 === 0 && n.g % 1 === 0 && n.b % 1 === 0;
        const scaleMultiplier = isWhole ? 2.0 : 1.0;

        const r = 9.0 * scaleMultiplier * zoom;
        const opacity = (0.55 + 0.45 * depthBoost) * 0.70;

        const isBlackNode = n.sum === 0;
        const strokeColor = isBlackNode ? "#ffffff" : "#0f172a";
        const strokeWidth = (isBlackNode ? 2 : 1) * zoom;

        return (
          <g key={n.id}>
            <circle cx={x} cy={y} r={r} fill={fill} opacity={opacity} stroke={strokeColor} strokeWidth={strokeWidth} />
          </g>
        );
      })}

      {(activeBalls.current.length > 0) && activeBalls.current.map((b) => {
        const tProg = (performance.now() - b.startTime) / 12000;
        
        // Render infinitely until the useRaf loop mathematically culls it off-screen
        if (tProg < 0) return null;

        // Latch the exact World-Space position and velocity based on the CURRENT camera angles.
        // This must be locked in by the main leading ball (tProg) before rendering older echoes.
        if (tProg > 1 && !b.exitLatched) {
          const mVel = [
            (b.endP[0] - b.startP[0]) - 0.45 * Math.PI * b.uBasis[0],
            (b.endP[1] - b.startP[1]) - 0.45 * Math.PI * b.uBasis[1],
            (b.endP[2] - b.startP[2]) - 0.45 * Math.PI * b.uBasis[2]
          ];
          
          let posRot = rotateZ(b.endP, psi);
          posRot = rotateY(posRot, theta);
          posRot = rotateX(posRot, phi);
          
          let velRot = rotateZ(mVel, psi);
          velRot = rotateY(velRot, theta);
          velRot = rotateX(velRot, phi);
          
          b.exitWorldPos = posRot;
          b.exitWorldVel = velRot;
          b.exitLatched = true;
        }

        const NUM_ECHOS = 16;
        const TRAIL_STEP = 0.008;
        const trailNodes = [];

        // Loop backwards so the oldest echoes render first (underneath newer ones)
        for (let i = NUM_ECHOS; i >= 0; i--) {
          const t = tProg - i * TRAIL_STEP;
          if (t < 0) continue;

          let pRot;
          let centerDepth;
          let fill;

          if (t <= 1) {
            // --- SPIRAL PHASE (Inside Cube: Locked to Cube Rotation) ---
            const linearX = b.startP[0] + (b.endP[0] - b.startP[0]) * t;
            const linearY = b.startP[1] + (b.endP[1] - b.startP[1]) * t;
            const linearZ = b.startP[2] + (b.endP[2] - b.startP[2]) * t;

            const spiralRadius = 0.45 * Math.sin(Math.PI * t);
            const angle = 4 * 2 * Math.PI * t;

            const uOffset = spiralRadius * Math.cos(angle);
            const vOffset = spiralRadius * Math.sin(angle);

            const px = linearX + uOffset * b.uBasis[0] + vOffset * b.vBasis[0];
            const py = linearY + uOffset * b.uBasis[1] + vOffset * b.vBasis[1];
            const pz = linearZ + uOffset * b.uBasis[2] + vOffset * b.vBasis[2];
            
            pRot = rotateZ([px, py, pz], psi);
            pRot = rotateY(pRot, theta);
            pRot = rotateX(pRot, phi);

            let linearRot = rotateZ([linearX, linearY, linearZ], psi);
            linearRot = rotateY(linearRot, theta);
            linearRot = rotateX(linearRot, phi);
            centerDepth = (linearRot[2] + 2.2) / 4.4;

            const isOutside = px < -1.35 || px > 1.35 || py < -1.35 || py > 1.35 || pz < -1.35 || pz > 1.35;
            const rVal = clamp((px + 1.35) / 2.7, 0, 1);
            const gVal = clamp((py + 1.35) / 2.7, 0, 1);
            const bVal = clamp((pz + 1.35) / 2.7, 0, 1);
            fill = isOutside ? "#ffffff" : rgbCss(rVal, gVal, bVal);

          } else {
            // --- TANGENT PHASE (Outside Cube: Free from Cube Rotation) ---
            const overT = t - 1;
            // Evolve purely in world space from the latched exit vector
            pRot = [
              b.exitWorldPos[0] + b.exitWorldVel[0] * overT,
              b.exitWorldPos[1] + b.exitWorldVel[1] * overT,
              b.exitWorldPos[2] + b.exitWorldVel[2] * overT
            ];
            
            // Depth and position are mapped directly off the world space structure
            centerDepth = (pRot[2] + 2.2) / 4.4;
            fill = "#ffffff";
          }

          const [sx, sy] = projectIso(pRot, width, height, zoom);
          const depthScale = 0.1 + 2.4 * clamp(centerDepth, -0.5, 1);
          const radius = 10 * depthScale * zoom;
          const isMainBall = i === 0;
          
          // Fade opacity based on the echo's position in the trail
          const opacity = isMainBall ? 1 : 0.65 * (1 - i / NUM_ECHOS);

          trailNodes.push(
            <circle 
              key={i} 
              cx={sx} 
              cy={sy} 
              r={radius} 
              fill={fill} 
              opacity={opacity} 
              stroke={isMainBall ? "#ffffff" : "none"} 
              strokeWidth={isMainBall ? 1.5 * depthScale * zoom : 0} 
            />
          );
        }

        return <g key={b.id}>{trailNodes}</g>;
      })}

      <text x={18} y={26} fontSize={12} fontWeight={800} fill="#e2e8f0">
        Projected 3D lattice over {"{0, 0.5, 1}³"}
      </text>
      <text x={18} y={46} fontSize={11} fontWeight={600} fill="#94a3b8">
        Drag to rotate. Wheel to zoom. { !showNodes && "Click cube to fire ray." }
      </text>
    </svg>
  );
});

// =========================================
// Main App
// =========================================

export default function App() {
  const binaryRef = useRef(null);
  const ternaryRef = useRef(null);

  const [autoRotateBinary, setAutoRotateBinary] = useState({ x: false, y: true, z: false });
  const [showNodesBinary, setShowNodesBinary] = useState(true);
  const [showEdgesBinary, setShowEdgesBinary] = useState(true);
  
  const [autoRotateTernary, setAutoRotateTernary] = useState({ x: false, y: true, z: false });
  const [showNodesTernary, setShowNodesTernary] = useState(true);
  const [showEdgesTernary, setShowEdgesTernary] = useState(true);

  return (
    <div className="w-full min-h-screen bg-gradient-to-br from-gray-950 to-gray-800 flex flex-col items-center py-12 space-y-16">
      
      {/* ================= Binary Lattice ================= */}
      <div className="w-[650px] h-[650px] rounded-2xl shadow-2xl overflow-hidden bg-black relative">
        <BinaryLatticeProjected 
          ref={binaryRef}
          width={650} 
          height={650} 
          autoRotate={autoRotateBinary} 
          showNodes={showNodesBinary} 
          showEdges={showEdgesBinary}
        />
        
        <div className="absolute top-5 right-5 flex flex-col space-y-2 z-10 w-40">
          <div className="bg-slate-800/80 p-2.5 rounded-md border border-slate-600 backdrop-blur-sm shadow-lg flex flex-col space-y-2.5">
            <div>
              <div className="text-slate-300 text-[9px] uppercase font-bold mb-1.5 tracking-wider">Auto-Rotate</div>
              <div className="flex space-x-1.5">
                <button onClick={() => setAutoRotateBinary(p => ({...p, x: !p.x}))} className={`flex-1 py-1 text-[10px] font-bold rounded transition-colors ${autoRotateBinary.x ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}`}>X</button>
                <button onClick={() => setAutoRotateBinary(p => ({...p, y: !p.y}))} className={`flex-1 py-1 text-[10px] font-bold rounded transition-colors ${autoRotateBinary.y ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}`}>Y</button>
                <button onClick={() => setAutoRotateBinary(p => ({...p, z: !p.z}))} className={`flex-1 py-1 text-[10px] font-bold rounded transition-colors ${autoRotateBinary.z ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}`}>Z</button>
              </div>
            </div>
            <div>
              <div className="text-slate-300 text-[9px] uppercase font-bold mb-1.5 tracking-wider">Visibility</div>
              <div className="flex space-x-1.5">
                <button onClick={() => setShowNodesBinary(p => !p)} className={`flex-1 py-1 text-[10px] font-bold rounded transition-colors ${showNodesBinary ? 'bg-indigo-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}`}>Nodes</button>
                <button onClick={() => setShowEdgesBinary(p => !p)} className={`flex-1 py-1 text-[10px] font-bold rounded transition-colors ${showEdgesBinary ? 'bg-indigo-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}`}>Edges</button>
              </div>
            </div>
            <button onClick={() => binaryRef.current?.resetView()} className="w-full py-1.5 mt-1 text-[10px] font-bold uppercase rounded bg-red-900/40 hover:bg-red-800/80 text-red-200 border border-red-800/50 transition-colors">Reset View</button>
          </div>
        </div>
      </div>

      {/* ================= Ternary Lattice ================= */}
      <div className="w-[650px] h-[650px] rounded-2xl shadow-2xl overflow-hidden bg-black relative">
        <TernaryLatticeProjected 
          ref={ternaryRef}
          width={650} 
          height={650} 
          autoRotate={autoRotateTernary} 
          showNodes={showNodesTernary} 
          showEdges={showEdgesTernary}
        />
        
        <div className="absolute top-5 right-5 flex flex-col space-y-2 z-10 w-40">
          <div className="bg-slate-800/80 p-2.5 rounded-md border border-slate-600 backdrop-blur-sm shadow-lg flex flex-col space-y-2.5">
            <div>
              <div className="text-slate-300 text-[9px] uppercase font-bold mb-1.5 tracking-wider">Auto-Rotate</div>
              <div className="flex space-x-1.5">
                <button onClick={() => setAutoRotateTernary(p => ({...p, x: !p.x}))} className={`flex-1 py-1 text-[10px] font-bold rounded transition-colors ${autoRotateTernary.x ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}`}>X</button>
                <button onClick={() => setAutoRotateTernary(p => ({...p, y: !p.y}))} className={`flex-1 py-1 text-[10px] font-bold rounded transition-colors ${autoRotateTernary.y ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}`}>Y</button>
                <button onClick={() => setAutoRotateTernary(p => ({...p, z: !p.z}))} className={`flex-1 py-1 text-[10px] font-bold rounded transition-colors ${autoRotateTernary.z ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}`}>Z</button>
              </div>
            </div>
            <div>
              <div className="text-slate-300 text-[9px] uppercase font-bold mb-1.5 tracking-wider">Visibility</div>
              <div className="flex space-x-1.5">
                <button onClick={() => setShowNodesTernary(p => !p)} className={`flex-1 py-1 text-[10px] font-bold rounded transition-colors ${showNodesTernary ? 'bg-indigo-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}`}>Nodes</button>
                <button onClick={() => setShowEdgesTernary(p => !p)} className={`flex-1 py-1 text-[10px] font-bold rounded transition-colors ${showEdgesTernary ? 'bg-indigo-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600'}`}>Edges</button>
              </div>
            </div>
            <button onClick={() => ternaryRef.current?.resetView()} className="w-full py-1.5 mt-1 text-[10px] font-bold uppercase rounded bg-red-900/40 hover:bg-red-800/80 text-red-200 border border-red-800/50 transition-colors">Reset View</button>
          </div>
        </div>
      </div>

      <div className="text-slate-200 text-sm max-w-[650px] text-center">
        Lattices rendered in pure SVG without external dependencies.
      </div>
    </div>
  );
}