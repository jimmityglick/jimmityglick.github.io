<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RGB Lattice</title>
  <style>
    :root {
      font-family: "Trebuchet MS", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top right, #1f2937 0%, #0b1220 45%, #020617 100%);
      color: #e2e8f0;
    }

    .page {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 20px;
      padding: 24px 12px;
    }

    .panel-wrap {
      position: relative;
      width: 100%;
      min-width: 650px;
      aspect-ratio: 1 / 1;
      border-radius: 18px;
      overflow: hidden;
      background: #000;
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.5);
    }

    .lattice-svg {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      border-radius: 18px;
      background: #000;
    }

    .panel-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      width: 170px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: rgba(30, 41, 59, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 10px;
      padding: 10px;
      backdrop-filter: blur(6px);
      font-size: 10px;
      letter-spacing: 0.2px;
    }

    .panel-controls p {
      margin: 0 0 6px;
      font-size: 9px;
      font-weight: 700;
      color: #cbd5e1;
      text-transform: uppercase;
      letter-spacing: 0.09em;
    }

    .button-row {
      display: flex;
      gap: 6px;
    }

    .control-btn {
      flex: 1;
      border: 0;
      border-radius: 6px;
      padding: 5px 0;
      font-size: 10px;
      font-weight: 700;
      color: #94a3b8;
      background: #334155;
      cursor: pointer;
      transition: transform 120ms ease, background-color 120ms ease;
    }

    .control-btn:hover {
      transform: translateY(-1px);
    }

    .control-btn.active {
      color: #ffffff;
      background: #2563eb;
    }

    .control-btn.visible {
      background: #4f46e5;
      color: #ffffff;
    }

    .reset-btn {
      width: 100%;
      padding: 6px 0;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      color: #fecdd3;
      background: rgba(127, 29, 29, 0.35);
      border: 1px solid rgba(220, 38, 38, 0.45);
    }

    .footer-note {
      text-align: center;
      max-width: 100%;
      width: 100%;
      color: #d4dae6;
      font-size: 14px;
    }

    .intro {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      color: #e2e8f0;
      max-width: 748px;
      margin: 0 auto;
      padding: 50px;
    }

    .intro h1 {
      margin: 0;
      font-size: 2rem;
      line-height: 1.2;
      letter-spacing: 0.01em;
    }

    .intro .eyebrow {
      margin: 0;
      font-size: 0.72rem;
      letter-spacing: 0.28em;
      text-transform: uppercase;
      color: #94a3b8;
      font-weight: 700;
    }

    .intro h2 {
      margin: 1.4rem 0 0.45rem;
      font-size: 1.3rem;
      line-height: 1.25;
      color: #f8fafc;
    }

    .intro h3 {
      margin: 1.1rem 0 0.4rem;
      font-size: 1.08rem;
      color: #e2e8f0;
      letter-spacing: 0.01em;
    }

    .intro .lead {
      margin: 0;
      font-size: 1.04rem;
      line-height: 1.55;
      color: #cbd5e1;
    }

    .intro p {
      margin: 0.45rem 0;
      line-height: 1.55;
      color: #cbd5e1;
    }

    .intro ul,
    .intro ol {
      margin: 0.5rem 0 0.5rem;
      padding-left: 1.2rem;
      line-height: 1.6;
      color: #cbd5e1;
    }

    .intro li {
      margin: 0.2rem 0;
    }

    .intro .rule {
      width: 100%;
      border: 0;
      border-top: 1px solid rgba(148, 163, 184, 0.35);
      margin: 1.4rem 0 0.6rem;
    }

    .intro code,
    .intro pre {
      font-family: "SFMono-Regular", Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 0.84rem;
    }

    .intro pre {
      background: rgba(2, 6, 23, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 10px;
      padding: 12px 14px;
      overflow-x: auto;
      color: #f8fafc;
      margin: 0.6rem 0;
      width: min(100%, 740px);
    }

    .intro .math {
      font-family: "Times New Roman", serif;
      letter-spacing: 0.01em;
      font-size: 0.95rem;
      color: #cbd5e1;
      margin: 0.25rem 0;
    }

    .diagrams-column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    @media (min-width: 1200px) {
      .page {
        display: grid;
        grid-template-columns: 1fr 1fr;
        align-items: start;
        column-gap: 24px;
      }

      .intro {
        grid-column: 1;
        max-width: none;
      }

      .diagrams-column {
        grid-column: 2;
        width: 100%;
        align-items: stretch;
      }

      .footer-note {
        grid-column: 1 / -1;
      }
    }

    @media (max-width: 680px) {
      .panel-controls {
        width: 150px;
      }

      .page {
        padding: 14px 10px 22px;
        gap: 16px;
      }
    }
  </style>
</head>
<body>
    <main class="page">
      <section class="intro">
        <p class="eyebrow">Concept Framework</p>
        <h1>The Lattice Sieve</h1>
        <h2>A Method for Building Conceptual Vector Spaces from Independent Axes</h2>
        <p class="lead">
          A conceptual domain becomes geometrically thinkable when it is expressed as a <strong>product space of independent axes</strong>,
          progressing from <strong>binary extremes</strong> to refined discrete levels, and eventually to a
          <strong>continuous coordinate system</strong>. The purpose is not classification; it is <strong>conceptual geometry</strong>:
          coordinates, interpolation, distance, gradients, and compositional structure.
        </p>

        <hr class="rule" />

        <h2>Core thesis</h2>
        <p>
          A conceptual domain becomes geometrically thinkable when it is expressed as a <strong>product space of
          independent axes</strong>, progressing from <strong>binary extremes</strong> to refined discrete levels and eventually an eventual
          continuous coordinate system. The purpose is not classification; it is <strong>conceptual geometry</strong>:
          coordinates, interpolation, distance, gradients, and compositional structure.
        </p>

        <h2>1. The object being built</h2>
        <h3>1.1 Conceptual Vector Space</h3>
        <p>A <strong>conceptual vector space</strong> is a coordinate system over a domain of things such that each thing corresponds to a point.</p>
        <ul>
          <li><strong>Point</strong> = assignment of values to a set of axes</li>
          <li><strong>Axes</strong> = independent dimensions of variation intrinsic to the domain element</li>
          <li><strong>Geometry</strong> = meaningful notions of proximity, interpolation, and movement along an axis</li>
        </ul>
        <p>This is not a taxonomy. A taxonomy is a partition. A vector space is a <strong>structure</strong>.</p>

        <h2>2. The Lattice Sieve in one line</h2>
        <p><em>Find independent axes by forcing the domain through a strict binary cube first, then refine each axis into multi-level chains, and optionally converge to a continuous coordinate system.</em></p>

        <h2>3. The three-layer construction</h2>
        <p>The method has three structural layers. Each layer is a stronger commitment.</p>

        <h3>Layer A. Boolean Skeleton (Bounds and Basis)</h3>
        <p><strong>Goal:</strong> establish <em>axes</em> and <em>extremes</em> with maximal falsifiability.</p>
        <ul>
          <li>Choose <strong>N independent binary primitives</strong>. Each axis has two states: low or high.</li>
          <li>The induced structure is a <strong>Boolean lattice</strong> <span class="math">C₂^N</span> with <span class="math">2^N</span> corners.</li>
          <li>The output is a <strong>basis and bounding box</strong> for the domain.</li>
        </ul>
        <p>This layer does not “contain” the full domain. It defines the coordinate frame: origin, extremes, and independence.</p>
        <p><strong>Why it matters:</strong> Binary axes are the hardest to fake. If an axis is not truly independent, the cube breaks quickly: categories collide, span cells, or generate forbidden corners.</p>

        <h3>Layer B. Product Lattice Refinement (Discrete Resolution)</h3>
        <p><strong>Goal:</strong> increase expressiveness without changing the underlying axes.</p>
        <ul>
          <li>Replace some binary axes with <strong>k-level chains</strong> (for example <span class="math">0, 0.5, 1</span>).</li>
          <li>The structure becomes a finite product lattice <span class="math">∏ C<sub>kᵢ</sub></span>.</li>
        </ul>
        <p>This is still a lattice and still coordinate-like. It is <strong>not</strong> Boolean unless all axes are binary.</p>
        <p><strong>Key fact:</strong> The Boolean cube is a <strong>sublattice</strong> of the refined product lattice, living at extremes of each axis.</p>

        <h3>Layer C. Continuous Coordinate Limit (Conceptual Geometry)</h3>
        <p><strong>Goal:</strong> move from discrete cells to true geometry.</p>
        <ul>
          <li>Replace discrete levels with continuous intervals where appropriate, yielding a continuous product space (for example <span class="math">[0,1]^N</span>).</li>
          <li>Now the domain admits interpolation, gradients, smooth tradeoff curves, and distance metrics (where defined).</li>
        </ul>
        <p>This is where conceptual RGB happens: the space becomes navigable, not just nameable.</p>

        <h2>4. The sieve mechanics</h2>
        <p>The sieve accepts or rejects candidate axes based on structural behavior.</p>

        <h3>4.1 Inputs</h3>
        <ul>
          <li><strong>Domain:</strong> the kind of thing being analyzed.</li>
          <li><strong>Candidate categories:</strong> an initial set of recognizable regions or types.</li>
          <li><strong>Candidate primitives:</strong> proposed axes of variation.</li>
        </ul>

        <h3>4.2 Constraints on valid axes</h3>
        <ol>
          <li><strong>Intrinsic:</strong> property of the domain element itself.</li>
          <li><strong>Independent:</strong> not logically implied by other axes.</li>
          <li><strong>Toggleable:</strong> you can change only this axis.</li>
          <li><strong>Meaningful:</strong> changing it is domain-recognized.</li>
        </ol>

        <h3>4.3 Structural failure modes</h3>
        <p><strong>A. Category spans multiple cells</strong> — it is not an atom. The category is a union or a mixture.</p>
        <p><strong>B. Two categories land in the same cell</strong> — false distinction or non-orthogonal criteria.</p>
        <p><strong>C. Empty cells appear</strong> — each empty cell is either unnamed but real, structurally forbidden, or degenerate.</p>
        <p><strong>D. Forbidden corners proliferate</strong> — detect dependencies or non-intrinsic leakage; revise axes.</p>

        <h2>5. The RGB validation example</h2>
        <h3>5.1 Boolean skeleton</h3>
        <p>Binary RGB yields the 8-corner cube <span class="math">{0,1}^3</span>.</p>
        <ul>
          <li>It defines basis vectors <strong>R, G, B</strong>, origin <strong>(0,0,0)</strong>, and bound <strong>(1,1,1)</strong>.</li>
          <li>It is a Boolean lattice and coordinate frame.</li>
        </ul>
        <h3>5.2 Refinement</h3>
        <p>Ternary RGB <span class="math">{0,0.5,1}^3</span> yields 27 points and keeps the original corners embedded.</p>
        <h3>5.3 Continuous limit</h3>
        <p>Continuous RGB <span class="math">[0,1]^3</span> yields the full gradient geometry.</p>
        <p><strong>Crucial interpretation:</strong> the binary cube holds the extremes that define the coordinate system; refining creates the full space.</p>

        <h2>6. Deliverables</h2>
        <ol>
          <li>Axis specification, intrinsicness argument, and toggle tests.</li>
          <li>Skeleton cube mapping: known regions, collisions, spans.</li>
          <li>Refinement plan: where multi-level axes are justified.</li>
          <li>Coordinate semantics: movement, interpolation, and optional distance metric.</li>
          <li>What geometry reveals: unnamed regions, invalid axes, unions, and true degrees of freedom.</li>
        </ol>

        <h2>7. Operating principles</h2>
        <h3>7.1 Boolean first, not because it is “true,” but because it is maximally diagnostic</h3>
        <p>Binary axes force independence and surface contradictions quickly.</p>
        <h3>7.2 Refinement is earned</h3>
        <p>An axis gets more than two levels only after it survives the skeleton.</p>
        <h3>7.3 The goal is navigability</h3>
        <p>Success is not prettier classification. Success is a coordinate system that supports controlled variation, interpolation, and discovery.</p>

        <h2>8. Prompt template</h2>
        <p>Use this when applying the method:</p>
        <pre><code># Lattice Sieve: Build a Conceptual Vector Space

## Domain
I want a conceptual coordinate system for:

[DOMAIN ELEMENT TYPE]: _______________________________

Examples of domain elements:
- _________________________________________________
- _________________________________________________

## Candidate regions (optional seed, not a goal)
List recognizable “regions” or types in this domain (5–15):
- _________________________________________________

## Step 1: Propose a Boolean skeleton
Propose N independent binary axes (prefer N = 3 or 4).
For each axis:
- Name it
- Define Low vs High precisely
- Argue it is intrinsic to the domain
- Provide two examples that differ ONLY on this axis (toggle test)

Then form the Boolean cube {0,1}^N.

## Step 2: Map known regions
Map each seed region/type to:
- a single corner (atom), or
- an explicit union of corners (higher-order region)

Flag:
- collisions (two regions in same corner)
- spans (a region covering many corners)

## Step 3: Diagnose empties
For each empty corner:
- Is it a real but unnamed region? Name + examples.
- Is it structurally forbidden? Prove the dependency.
- Is it degenerate? Explain which axes collapse.

If many forbidden corners appear, revise axes.

## Step 4: Refine axes into a product lattice
For axes that survived and merit nuance, refine them into k-level chains:
Example levels: {0, 0.5, 1} or {0,1,2,3}.

Build the product lattice ∏ C_kᵢ.
Repeat mapping and gap analysis.</code></pre>
    </section>

    <section class="diagrams-column">
      <section class="panel-wrap" id="binaryPanel">
        <svg id="binarySvg" class="lattice-svg"></svg>
        <aside class="panel-controls">
          <div>
            <p>Auto-Rotate</p>
            <div class="button-row">
              <button id="binary-toggle-x" class="control-btn" data-type="axis">X</button>
              <button id="binary-toggle-y" class="control-btn active" data-type="axis">Y</button>
              <button id="binary-toggle-z" class="control-btn" data-type="axis">Z</button>
            </div>
          </div>
          <div>
            <p>Visibility</p>
            <div class="button-row">
              <button id="binary-toggle-nodes" class="control-btn visible" data-type="visibility">Nodes</button>
              <button id="binary-toggle-edges" class="control-btn visible" data-type="visibility">Edges</button>
            </div>
          </div>
          <button id="binary-reset" class="reset-btn">Reset View</button>
        </aside>
      </section>

      <section class="panel-wrap" id="ternaryPanel">
        <svg id="ternarySvg" class="lattice-svg"></svg>
        <aside class="panel-controls">
          <div>
            <p>Auto-Rotate</p>
            <div class="button-row">
              <button id="ternary-toggle-x" class="control-btn" data-type="axis">X</button>
              <button id="ternary-toggle-y" class="control-btn active" data-type="axis">Y</button>
              <button id="ternary-toggle-z" class="control-btn" data-type="axis">Z</button>
            </div>
          </div>
          <div>
            <p>Visibility</p>
            <div class="button-row">
              <button id="ternary-toggle-nodes" class="control-btn visible" data-type="visibility">Nodes</button>
              <button id="ternary-toggle-edges" class="control-btn visible" data-type="visibility">Edges</button>
            </div>
          </div>
          <button id="ternary-reset" class="reset-btn">Reset View</button>
        </aside>
      </section>
    </section>

    <p class="footer-note">Lattices rendered in pure SVG with no React/build tooling.</p>
  </main>

  <script>
    (() => {
      const ROT_SENS = 0.008;
      const AUTO_ROT_SPEED = 0.45;
      const ZOOM_MIN = 0.6;
      const ZOOM_MAX = 2.2;

      const colorMapBinary = {
        "000": "0",
        "100": "#ff1a1a",
        "010": "#00d26a",
        "001": "#2a6bff",
        "110": "#ffe600",
        "101": "#ff2bd6",
        "011": "#00e7ff",
        "111": "#ffffff",
      };

      const labelMapBinary = {
        "000": "∅",
        "100": "R",
        "010": "G",
        "001": "B",
        "110": "R+G",
        "101": "R+B",
        "011": "G+B",
        "111": "R+G+B",
      };

      function assert(cond, msg) {
        if (!cond) throw new Error(msg);
      }

      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }

      function rotateZ([x, y, z], a) {
        const c = Math.cos(a);
        const s = Math.sin(a);
        return [x * c - y * s, x * s + y * c, z];
      }

      function rotateY([x, y, z], a) {
        const c = Math.cos(a);
        const s = Math.sin(a);
        return [x * c + z * s, y, -x * s + z * c];
      }

      function rotateX([x, y, z], a) {
        const c = Math.cos(a);
        const s = Math.sin(a);
        return [x, y * c - z * s, y * s + z * c];
      }

      function projectIso([x, y, z], w, h, zoom) {
        const base = Math.min(w, h) * 0.22;
        const scale = base * zoom;
        const px = (x + 0.85 * z) * scale;
        const py = (-y + 0.55 * z) * scale;
        return [w / 2 + px, h / 2 + py, z];
      }

      function crossProduct(a, b) {
        return [
          a[1] * b[2] - a[2] * b[1],
          a[2] * b[0] - a[0] * b[2],
          a[0] * b[1] - a[1] * b[0],
        ];
      }

      function normalize(v) {
        const mag = Math.hypot(v[0], v[1], v[2]);
        return mag === 0 ? [0, 0, 0] : [v[0] / mag, v[1] / mag, v[2] / mag];
      }

      function intersectCube(origin, dir, size) {
        let tmin = -Infinity;
        let tmax = Infinity;

        for (let i = 0; i < 3; i++) {
          if (Math.abs(dir[i]) < 1e-6) {
            if (origin[i] < -size || origin[i] > size) return null;
          } else {
            let t1 = (-size - origin[i]) / dir[i];
            let t2 = (size - origin[i]) / dir[i];
            if (t1 > t2) {
              const temp = t1;
              t1 = t2;
              t2 = temp;
            }
            tmin = Math.max(tmin, t1);
            tmax = Math.min(tmax, t2);
          }
        }

        if (tmax >= tmin && tmax > 0) {
          return { start: Math.max(0, tmin), end: tmax };
        }
        return null;
      }

      function applyDragRotation(state, dx, dy) {
        const sensitivity = ROT_SENS;
        return {
          theta: state.theta - dx * sensitivity,
          phi: state.phi - dy * sensitivity,
        };
      }

      function rgbCss(r, g, b) {
        const to255 = (v) => Math.round(v * 255);
        return `rgb(${to255(r)}, ${to255(g)}, ${to255(b)})`;
      }

      function textColorForFill(fill) {
        const hex = fill.replace("#", "");
        const r = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        return luminance > 160 ? "#000000" : "#ffffff";
      }

      function buildBinaryGraph3D() {
        const nodes = [];
        const edges = [];
        const scale = 1.35;
        const levels = [0, 1];

        for (const r of levels) {
          for (const g of levels) {
            for (const b of levels) {
              const id = `${r}${g}${b}`;
              const x = (r === 0 ? -1 : 1) * scale;
              const y = (g === 0 ? -1 : 1) * scale;
              const z = (b === 0 ? -1 : 1) * scale;
              nodes.push({
                id,
                r,
                g,
                b,
                pos: [x, y, z],
                sum: r + g + b,
                label: labelMapBinary[id],
              });
            }
          }
        }

        for (const a of nodes) {
          for (const b of nodes) {
            const dr = b.r - a.r;
            const dg = b.g - a.g;
            const db = b.b - a.b;
            if (dr >= 0 && dg >= 0 && db >= 0 && dr + dg + db === 1) {
              edges.push([a.id, b.id]);
            }
          }
        }

        assert(nodes.length === 8, "Binary nodes must be 8");
        assert(edges.length === 12, "Binary edges must be 12");
        return { nodes, edges };
      }

      function toCenteredCoord(v) {
        if (v === 0) return -1;
        if (v === 0.5) return 0;
        return 1;
      }

      function buildTernaryGraph() {
        const nodes = [];
        const edges = [];
        const scale = 1.35;
        const levels = [0, 0.5, 1];

        for (const r of levels) {
          for (const g of levels) {
            for (const b of levels) {
              const id = `${r}-${g}-${b}`;
              const x = toCenteredCoord(r) * scale;
              const y = toCenteredCoord(g) * scale;
              const z = toCenteredCoord(b) * scale;
              nodes.push({
                id,
                r,
                g,
                b,
                pos: [x, y, z],
                sum: r + g + b,
              });
            }
          }
        }

        for (const a of nodes) {
          for (const b of nodes) {
            const dr = b.r - a.r;
            const dg = b.g - a.g;
            const db = b.b - a.b;
            const positives = [dr, dg, db].filter((d) => d === 0.5);
            const zeros = [dr, dg, db].filter((d) => d === 0);
            if (positives.length === 1 && zeros.length === 2) {
              edges.push([a.id, b.id]);
            }
          }
        }

        assert(nodes.length === 27, "Ternary nodes must be 27");
        return { nodes, edges };
      }

      const BINARY_3D = buildBinaryGraph3D();
      const TERNARY_3D = buildTernaryGraph();

      function createSVGElement(tag, attrs, text) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (const [k, v] of Object.entries(attrs)) {
          if (v === undefined || v === null) continue;
          el.setAttribute(k, String(v));
        }
        if (text !== undefined) el.textContent = text;
        return el;
      }

      function clear(svg) {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
      }

      function getSize(svg) {
        const rect = svg.getBoundingClientRect();
        const w = Math.max(1, rect.width);
        const h = Math.max(1, rect.height);
        return { w, h };
      }

      function makeLatticeController({
        svg,
        graph,
        autoRotateState,
        showNodesRef,
        showEdgesRef,
        isBinary,
        onFire,
      }) {
        let psi = 0;
        let theta = 0;
        let phi = 0.62;
        let zoom = 1.0;
        let dragging = false;
        const dragState = { active: false, lastX: 0, lastY: 0, startX: 0, startY: 0, pointerId: null };
        const activeBalls = [];
        let ballCounter = 0;

        function setRotation(next) {
          if (typeof next.psi === "number") psi = next.psi;
          if (typeof next.theta === "number") theta = next.theta;
          if (typeof next.phi === "number") phi = next.phi;
        }

        function rotateAuto(dt) {
          if (!dragging) {
            if (autoRotateState.x) phi += dt * AUTO_ROT_SPEED;
            if (autoRotateState.y) theta += dt * AUTO_ROT_SPEED;
            if (autoRotateState.z) psi += dt * AUTO_ROT_SPEED;
          }
        }

        function handleWheel(e) {
          e.preventDefault();
          const next = e.deltaY > 0 ? zoom * 0.92 : zoom * 1.08;
          zoom = clamp(next, ZOOM_MIN, ZOOM_MAX);
        }

        function startDrag(e) {
          if (e.button !== undefined && e.button !== 0) return;
          if (!svg) return;
          svg.setPointerCapture?.(e.pointerId);
          dragState.active = true;
          dragState.lastX = e.clientX;
          dragState.lastY = e.clientY;
          dragState.startX = e.clientX;
          dragState.startY = e.clientY;
          dragState.pointerId = e.pointerId;
          dragging = true;
          svg.style.cursor = "grabbing";
        }

        function moveDrag(e) {
          if (!dragState.active) return;
          const dx = e.clientX - dragState.lastX;
          const dy = e.clientY - dragState.lastY;
          dragState.lastX = e.clientX;
          dragState.lastY = e.clientY;

          const next = applyDragRotation({ theta, phi }, dx, dy);
          theta = next.theta;
          phi = next.phi;
        }

        function endDrag(e) {
          if (!dragState.active) return;
          try {
            svg.releasePointerCapture?.(e.pointerId);
          } catch (_) {
            // ignore
          }

          if (onFire) {
            const dist = Math.hypot(e.clientX - dragState.startX, e.clientY - dragState.startY);
            if (dist < 5) {
              onFire(e.clientX, e.clientY);
            }
          }

          dragState.active = false;
          dragState.pointerId = null;
          dragging = false;
          svg.style.cursor = "grab";
        }

        function fireBall(clientX, clientY) {
          const { w, h } = getSize(svg);
          const rect = svg.getBoundingClientRect();
          const base = Math.min(w, h) * 0.22;
          const scale = base * zoom;

          const cx = clientX - rect.left - w / 2;
          const cy = clientY - rect.top - h / 2;
          const originRot = [cx / scale, -cy / scale, 0];
          const dirRot = [0.85, -0.55, -1];

          const pullBack = 5;
          const pulledOriginRot = [
            originRot[0] - dirRot[0] * pullBack,
            originRot[1] - dirRot[1] * pullBack,
            originRot[2] - dirRot[2] * pullBack,
          ];

          let originM = rotateX(pulledOriginRot, -phi);
          originM = rotateY(originM, -theta);
          originM = rotateZ(originM, -psi);

          let dirM = rotateX(dirRot, -phi);
          dirM = rotateY(dirM, -theta);
          dirM = rotateZ(dirM, -psi);

          const hit = intersectCube(originM, dirM, 1.35);
          if (!hit) return;

          const startP = [
            originM[0] + hit.start * dirM[0],
            originM[1] + hit.start * dirM[1],
            originM[2] + hit.start * dirM[2],
          ];
          const endP = [
            originM[0] + hit.end * dirM[0],
            originM[1] + hit.end * dirM[1],
            originM[2] + hit.end * dirM[2],
          ];

          const lineVel = [
            endP[0] - startP[0],
            endP[1] - startP[1],
            endP[2] - startP[2],
          ];

          const axisDir = normalize(dirM);
          let up = [0, 1, 0];
          if (Math.abs(axisDir[1]) > 0.99) up = [1, 0, 0];

          const uBasis = normalize(crossProduct(up, axisDir));
          const vBasis = normalize(crossProduct(axisDir, uBasis));

          activeBalls.push({
            id: Math.random().toString(36).slice(2),
            startP,
            endP,
            lineVel,
            uBasis,
            vBasis,
            spinDirection: (ballCounter % 2 === 0 ? 1 : -1),
            startTime: performance.now(),
            exitLatched: false,
          });
          ballCounter += 1;
        }

        function updateBalls(now) {
          if (!activeBalls.length) return;
          for (let i = activeBalls.length - 1; i >= 0; i--) {
            const b = activeBalls[i];
            const tProg = (now - b.startTime) / 12000;

            if (tProg <= 1) continue;

            if (b.exitLatched) {
              const over = tProg - 1;
              const px = b.exitWorldPos[0] + b.exitWorldVel[0] * over;
              const py = b.exitWorldPos[1] + b.exitWorldVel[1] * over;
              const pz = b.exitWorldPos[2] + b.exitWorldVel[2] * over;
              if (px * px + py * py + pz * pz >= 400) {
                activeBalls.splice(i, 1);
              }
              continue;
            }

            if (tProg >= 10) {
              activeBalls.splice(i, 1);
            }
          }
        }

        function draw() {
          const { w, h } = getSize(svg);
          svg.setAttribute("viewBox", `0 0 ${w} ${h}`);

          const posById = {};
          const nodes2d = graph.nodes
            .map((n) => {
              let p = rotateZ(n.pos, psi);
              p = rotateY(p, theta);
              p = rotateX(p, phi);
              const screen = projectIso(p, w, h, zoom);
              posById[n.id] = screen;
              return { ...n, screen };
            })
            .sort((a, b) => a.screen[2] - b.screen[2]);

          const edges2d = graph.edges.map(([a, b]) => {
            const pa = posById[a];
            const pb = posById[b];
            return { a, b, pa, pb };
          });

          clear(svg);

          if (showEdgesRef.value) {
            for (const e of edges2d) {
              if (!e.pa || !e.pb) continue;
              const edgeColor = isBinary ? "#64748b" : "#94a3b8";
              const edgeWidth = isBinary ? "2.5" : "1.5";
              const edgeOpacity = isBinary ? "0.4" : "0.22";
              svg.appendChild(
                createSVGElement("line", {
                  x1: e.pa[0],
                  y1: e.pa[1],
                  x2: e.pb[0],
                  y2: e.pb[1],
                  stroke: edgeColor,
                  strokeWidth: edgeWidth,
                  opacity: edgeOpacity,
                })
              );
            }
          }

          if (showNodesRef.value) {
            for (const n of nodes2d) {
              const [x, y, z] = n.screen;
              const depth = (z + 2.2) / 4.4;
              const depthBoost = 0.45 + 0.65 * clamp(depth, 0, 1);

              const fill = isBinary
                ? colorMapBinary[n.id]
                : rgbCss(n.r, n.g, n.b);

              const isBlackNode = isBinary ? n.id === "000" : n.sum === 0;
              const strokeColor = isBlackNode ? "#ffffff" : isBinary ? "#e2e8f0" : "#0f172a";
              const radius = isBinary ? 30 * zoom : (n.r % 1 === 0 && n.g % 1 === 0 && n.b % 1 === 0 ? 18 * zoom : 9 * zoom);
              const strokeWidth = (isBlackNode ? 3 : (isBinary ? 2 : 1)) * zoom;
              const opacity = isBinary ? (0.75 + 0.25 * depthBoost) * 0.8 : (0.55 + 0.45 * depthBoost) * 0.7;
              const labelSize = 12 + 16 * ((clamp(zoom, ZOOM_MIN, ZOOM_MAX) - ZOOM_MIN) / (ZOOM_MAX - ZOOM_MIN));

                const gEl = createSVGElement("g", { opacity: String(opacity) });
              const c = createSVGElement("circle", {
                cx: x,
                cy: y,
                r: radius,
                fill,
                stroke: strokeColor,
                strokeWidth: String(strokeWidth),
                style: isBinary ? "filter: drop-shadow(0px 4px 8px rgba(0,0,0,0.5));" : undefined,
              });
              gEl.appendChild(c);

              if (isBinary) {
                gEl.appendChild(
                  createSVGElement(
                    "text",
                    {
                      x,
                      y,
                      "text-anchor": "middle",
                      "dominant-baseline": "middle",
                      "font-size": String(labelSize),
                      fontWeight: "800",
                      fill: textColorForFill(fill),
                    },
                    n.label
                  )
                );
              }

              svg.appendChild(gEl);
            }
          }

          if (!isBinary) {
            const now = performance.now();
            updateBalls(now);

            for (const b of activeBalls) {
              const tProg = (now - b.startTime) / 12000;
              if (tProg < 0) continue;

              if (tProg > 1 && !b.exitLatched) {
                const mVel = b.lineVel;

                let posRot = rotateZ(b.endP, psi);
                posRot = rotateY(posRot, theta);
                posRot = rotateX(posRot, phi);
                let velRot = rotateZ(mVel, psi);
                velRot = rotateY(velRot, theta);
                velRot = rotateX(velRot, phi);
                b.exitWorldPos = posRot;
                b.exitWorldVel = velRot;
                b.exitLatched = true;
              }

              const NUM_ECHOS = 16;
              const TRAIL_STEP = 0.008;
              const trail = [];

              for (let i = NUM_ECHOS; i >= 0; i--) {
                const t = tProg - i * TRAIL_STEP;
                if (t < 0) continue;

                let pRot;
                let centerDepth;
                let fill;

                if (t <= 1) {
                  const linearX = b.startP[0] + (b.endP[0] - b.startP[0]) * t;
                  const linearY = b.startP[1] + (b.endP[1] - b.startP[1]) * t;
                  const linearZ = b.startP[2] + (b.endP[2] - b.startP[2]) * t;

                  const spiralRadius = 0.45 * Math.sin(Math.PI * t);
                  const angle = 4 * 2 * Math.PI * t * b.spinDirection;
                  const uOffset = spiralRadius * Math.cos(angle);
                  const vOffset = spiralRadius * Math.sin(angle);

                  const px = linearX + uOffset * b.uBasis[0] + vOffset * b.vBasis[0];
                  const py = linearY + uOffset * b.uBasis[1] + vOffset * b.vBasis[1];
                  const pz = linearZ + uOffset * b.uBasis[2] + vOffset * b.vBasis[2];

                  pRot = rotateZ([px, py, pz], psi);
                  pRot = rotateY(pRot, theta);
                  pRot = rotateX(pRot, phi);

                  let linearForDepth = rotateZ([linearX, linearY, linearZ], psi);
                  linearForDepth = rotateY(linearForDepth, theta);
                  linearForDepth = rotateX(linearForDepth, phi);
                  centerDepth = (linearForDepth[2] + 2.2) / 4.4;

                  const isOutside = px < -1.35 || px > 1.35 || py < -1.35 || py > 1.35 || pz < -1.35 || pz > 1.35;
                  const rVal = clamp((px + 1.35) / 2.7, 0, 1);
                  const gVal = clamp((py + 1.35) / 2.7, 0, 1);
                  const bVal = clamp((pz + 1.35) / 2.7, 0, 1);
                  fill = isOutside ? "#ffffff" : rgbCss(rVal, gVal, bVal);
                } else {
                  const overT = t - 1;
                  pRot = [
                    b.exitWorldPos[0] + b.exitWorldVel[0] * overT,
                    b.exitWorldPos[1] + b.exitWorldVel[1] * overT,
                    b.exitWorldPos[2] + b.exitWorldVel[2] * overT,
                  ];
                  centerDepth = (pRot[2] + 2.2) / 4.4;
                  fill = "#ffffff";
                }

                const [sx, sy] = projectIso(pRot, w, h, zoom);
                const depthScale = Math.max(0, 0.1 + 2.4 * clamp(centerDepth, -0.5, 1));
                const isMain = i === 0;
                const radius = Math.max(0, 10 * depthScale * zoom);
                const opacity = isMain ? 1 : 0.65 * (1 - i / NUM_ECHOS);
                const strokeWidth = Math.max(0, 1.5 * depthScale * zoom);

                trail.push(
                  createSVGElement("circle", {
                    cx: sx,
                    cy: sy,
                    r: radius,
                    fill,
                    opacity: String(opacity),
                    stroke: isMain ? "#ffffff" : "none",
                    strokeWidth: String(isMain ? strokeWidth : 0),
                  })
                );
              }

              const gEl = createSVGElement("g", {});
              for (const p of trail) gEl.appendChild(p);
              svg.appendChild(gEl);
            }
          }

          svg.appendChild(
            createSVGElement(
              "text",
              {
                x: 18,
                y: 26,
                fontSize: 12,
                fontWeight: 800,
                fill: "#e2e8f0",
              },
              isBinary
                ? "Projected 3D lattice over {0, 1}7"
                : "Projected 3D lattice over {0, 0.5, 1}7"
            )
          );

          svg.appendChild(
            createSVGElement(
              "text",
              {
                x: 18,
                y: 46,
                fontSize: 11,
                fontWeight: 600,
                fill: "#94a3b8",
              },
              isBinary
                ? "Drag to rotate. Wheel to zoom."
                : `Drag to rotate. Wheel to zoom.${showNodesRef.value ? "" : " Click cube to fire ray."}`
            )
          );
        }

        function loop(now) {
          const prev = loop._prevTime || now;
          const dt = (now - prev) / 1000;
          loop._prevTime = now;

          rotateAuto(dt);
          draw();
          requestAnimationFrame(loop);
        }

        const handler = {
          resetView() {
            psi = 0;
            theta = 0;
            phi = 0.62;
            zoom = 1;
          },
        };

        function attachInteractions() {
          svg.addEventListener("pointerdown", startDrag);
          svg.addEventListener("pointermove", moveDrag);
          svg.addEventListener("pointerup", endDrag);
          svg.addEventListener("pointercancel", endDrag);
          svg.addEventListener("pointerleave", endDrag);
          svg.addEventListener("wheel", handleWheel, { passive: false });
          svg.style.cursor = "grab";
        }

        attachInteractions();
        requestAnimationFrame(loop);

        return {
          getState() {
            return { psi, theta, phi, zoom };
          },
          setRotationState(next) {
            setRotation(next);
          },
          resetView: handler.resetView,
          fireBall,
          _update: draw,
        };
      }

      const binaryToggleX = document.getElementById("binary-toggle-x");
      const binaryToggleY = document.getElementById("binary-toggle-y");
      const binaryToggleZ = document.getElementById("binary-toggle-z");
      const binaryToggleNodes = document.getElementById("binary-toggle-nodes");
      const binaryToggleEdges = document.getElementById("binary-toggle-edges");
      const binaryReset = document.getElementById("binary-reset");

      const ternaryToggleX = document.getElementById("ternary-toggle-x");
      const ternaryToggleY = document.getElementById("ternary-toggle-y");
      const ternaryToggleZ = document.getElementById("ternary-toggle-z");
      const ternaryToggleNodes = document.getElementById("ternary-toggle-nodes");
      const ternaryToggleEdges = document.getElementById("ternary-toggle-edges");
      const ternaryReset = document.getElementById("ternary-reset");

      const binaryRef = { current: null };
      const ternaryRef = { current: null };

      const binaryState = {
        autoRotate: { x: false, y: true, z: false },
        showNodes: { value: true },
        showEdges: { value: true },
      };

      const ternaryState = {
        autoRotate: { x: false, y: true, z: false },
        showNodes: { value: true },
        showEdges: { value: true },
      };

      const binaryController = makeLatticeController({
        svg: document.getElementById("binarySvg"),
        graph: BINARY_3D,
        autoRotateState: binaryState.autoRotate,
        showNodesRef: binaryState.showNodes,
        showEdgesRef: binaryState.showEdges,
        isBinary: true,
        onFire: null,
      });

      const ternaryController = makeLatticeController({
        svg: document.getElementById("ternarySvg"),
        graph: TERNARY_3D,
        autoRotateState: ternaryState.autoRotate,
        showNodesRef: ternaryState.showNodes,
        showEdgesRef: ternaryState.showEdges,
        isBinary: false,
        onFire: (x, y) => ternaryController.fireBall(x, y),
      });

      binaryRef.current = binaryController;
      ternaryRef.current = ternaryController;

      function syncButton(btn, active, activeClass = "active") {
        btn.classList.toggle(activeClass, active);
      }

      function syncBinaryButtons() {
        syncButton(binaryToggleX, binaryState.autoRotate.x);
        syncButton(binaryToggleY, binaryState.autoRotate.y);
        syncButton(binaryToggleZ, binaryState.autoRotate.z);
        syncButton(binaryToggleNodes, binaryState.showNodes.value, "visible");
        syncButton(binaryToggleEdges, binaryState.showEdges.value, "visible");
      }

      function syncTernaryButtons() {
        syncButton(ternaryToggleX, ternaryState.autoRotate.x);
        syncButton(ternaryToggleY, ternaryState.autoRotate.y);
        syncButton(ternaryToggleZ, ternaryState.autoRotate.z);
        syncButton(ternaryToggleNodes, ternaryState.showNodes.value, "visible");
        syncButton(ternaryToggleEdges, ternaryState.showEdges.value, "visible");
      }

      binaryToggleX.addEventListener("click", () => {
        binaryState.autoRotate.x = !binaryState.autoRotate.x;
        syncBinaryButtons();
      });

      binaryToggleY.addEventListener("click", () => {
        binaryState.autoRotate.y = !binaryState.autoRotate.y;
        syncBinaryButtons();
      });

      binaryToggleZ.addEventListener("click", () => {
        binaryState.autoRotate.z = !binaryState.autoRotate.z;
        syncBinaryButtons();
      });

      binaryToggleNodes.addEventListener("click", () => {
        binaryState.showNodes.value = !binaryState.showNodes.value;
        syncBinaryButtons();
      });

      binaryToggleEdges.addEventListener("click", () => {
        binaryState.showEdges.value = !binaryState.showEdges.value;
        syncBinaryButtons();
      });

      ternaryToggleX.addEventListener("click", () => {
        ternaryState.autoRotate.x = !ternaryState.autoRotate.x;
        syncTernaryButtons();
      });

      ternaryToggleY.addEventListener("click", () => {
        ternaryState.autoRotate.y = !ternaryState.autoRotate.y;
        syncTernaryButtons();
      });

      ternaryToggleZ.addEventListener("click", () => {
        ternaryState.autoRotate.z = !ternaryState.autoRotate.z;
        syncTernaryButtons();
      });

      ternaryToggleNodes.addEventListener("click", () => {
        ternaryState.showNodes.value = !ternaryState.showNodes.value;
        syncTernaryButtons();
      });

      ternaryToggleEdges.addEventListener("click", () => {
        ternaryState.showEdges.value = !ternaryState.showEdges.value;
        syncTernaryButtons();
      });

      binaryReset.addEventListener("click", () => {
        binaryRef.current?.resetView();
      });

      ternaryReset.addEventListener("click", () => {
        ternaryRef.current?.resetView();
      });

      syncBinaryButtons();
      syncTernaryButtons();
    })();
  </script>
</body>
</html>
