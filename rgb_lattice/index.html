<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RGB Lattice</title>
  <style>
    :root {
      font-family: "Trebuchet MS", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top right, #1f2937 0%, #0b1220 45%, #020617 100%);
      color: #e2e8f0;
    }

    .page {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 24px 12px;
    }

    .panel-wrap {
      position: relative;
      width: min(650px, calc(100vw - 24px));
      aspect-ratio: 1 / 1;
      border-radius: 18px;
      overflow: hidden;
      background: #000;
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.5);
    }

    .lattice-svg {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      border-radius: 18px;
      background: #000;
    }

    .panel-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      width: 170px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: rgba(30, 41, 59, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 10px;
      padding: 10px;
      backdrop-filter: blur(6px);
      font-size: 10px;
      letter-spacing: 0.2px;
    }

    .panel-controls p {
      margin: 0 0 6px;
      font-size: 9px;
      font-weight: 700;
      color: #cbd5e1;
      text-transform: uppercase;
      letter-spacing: 0.09em;
    }

    .button-row {
      display: flex;
      gap: 6px;
    }

    .control-btn {
      flex: 1;
      border: 0;
      border-radius: 6px;
      padding: 5px 0;
      font-size: 10px;
      font-weight: 700;
      color: #94a3b8;
      background: #334155;
      cursor: pointer;
      transition: transform 120ms ease, background-color 120ms ease;
    }

    .control-btn:hover {
      transform: translateY(-1px);
    }

    .control-btn.active {
      color: #ffffff;
      background: #2563eb;
    }

    .control-btn.visible {
      background: #4f46e5;
      color: #ffffff;
    }

    .reset-btn {
      width: 100%;
      padding: 6px 0;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      color: #fecdd3;
      background: rgba(127, 29, 29, 0.35);
      border: 1px solid rgba(220, 38, 38, 0.45);
    }

    .footer-note {
      text-align: center;
      max-width: min(650px, calc(100vw - 24px));
      color: #d4dae6;
      font-size: 14px;
    }

    @media (max-width: 680px) {
      .panel-controls {
        width: 150px;
      }

      .page {
        padding: 14px 10px 22px;
        gap: 16px;
      }
    }
  </style>
</head>
<body>
  <main class="page">
    <section class="panel-wrap" id="binaryPanel">
      <svg id="binarySvg" class="lattice-svg"></svg>
      <aside class="panel-controls">
        <div>
          <p>Auto-Rotate</p>
          <div class="button-row">
            <button id="binary-toggle-x" class="control-btn" data-type="axis">X</button>
            <button id="binary-toggle-y" class="control-btn active" data-type="axis">Y</button>
            <button id="binary-toggle-z" class="control-btn" data-type="axis">Z</button>
          </div>
        </div>
        <div>
          <p>Visibility</p>
          <div class="button-row">
            <button id="binary-toggle-nodes" class="control-btn visible" data-type="visibility">Nodes</button>
            <button id="binary-toggle-edges" class="control-btn visible" data-type="visibility">Edges</button>
          </div>
        </div>
        <button id="binary-reset" class="reset-btn">Reset View</button>
      </aside>
    </section>

    <section class="panel-wrap" id="ternaryPanel">
      <svg id="ternarySvg" class="lattice-svg"></svg>
      <aside class="panel-controls">
        <div>
          <p>Auto-Rotate</p>
          <div class="button-row">
            <button id="ternary-toggle-x" class="control-btn" data-type="axis">X</button>
            <button id="ternary-toggle-y" class="control-btn active" data-type="axis">Y</button>
            <button id="ternary-toggle-z" class="control-btn" data-type="axis">Z</button>
          </div>
        </div>
        <div>
          <p>Visibility</p>
          <div class="button-row">
            <button id="ternary-toggle-nodes" class="control-btn visible" data-type="visibility">Nodes</button>
            <button id="ternary-toggle-edges" class="control-btn visible" data-type="visibility">Edges</button>
          </div>
        </div>
        <button id="ternary-reset" class="reset-btn">Reset View</button>
      </aside>
    </section>

    <p class="footer-note">Lattices rendered in pure SVG with no React/build tooling.</p>
  </main>

  <script>
    (() => {
      const ROT_SENS = 0.008;
      const AUTO_ROT_SPEED = 0.45;
      const ZOOM_MIN = 0.6;
      const ZOOM_MAX = 2.2;

      const colorMapBinary = {
        "000": "0",
        "100": "#ff1a1a",
        "010": "#00d26a",
        "001": "#2a6bff",
        "110": "#ffe600",
        "101": "#ff2bd6",
        "011": "#00e7ff",
        "111": "#ffffff",
      };

      const labelMapBinary = {
        "000": "-",
        "100": "R",
        "010": "G",
        "001": "B",
        "110": "R+G",
        "101": "R+B",
        "011": "G+B",
        "111": "R+G+B",
      };

      function assert(cond, msg) {
        if (!cond) throw new Error(msg);
      }

      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }

      function rotateZ([x, y, z], a) {
        const c = Math.cos(a);
        const s = Math.sin(a);
        return [x * c - y * s, x * s + y * c, z];
      }

      function rotateY([x, y, z], a) {
        const c = Math.cos(a);
        const s = Math.sin(a);
        return [x * c + z * s, y, -x * s + z * c];
      }

      function rotateX([x, y, z], a) {
        const c = Math.cos(a);
        const s = Math.sin(a);
        return [x, y * c - z * s, y * s + z * c];
      }

      function projectIso([x, y, z], w, h, zoom) {
        const base = Math.min(w, h) * 0.22;
        const scale = base * zoom;
        const px = (x + 0.85 * z) * scale;
        const py = (-y + 0.55 * z) * scale;
        return [w / 2 + px, h / 2 + py, z];
      }

      function crossProduct(a, b) {
        return [
          a[1] * b[2] - a[2] * b[1],
          a[2] * b[0] - a[0] * b[2],
          a[0] * b[1] - a[1] * b[0],
        ];
      }

      function normalize(v) {
        const mag = Math.hypot(v[0], v[1], v[2]);
        return mag === 0 ? [0, 0, 0] : [v[0] / mag, v[1] / mag, v[2] / mag];
      }

      function intersectCube(origin, dir, size) {
        let tmin = -Infinity;
        let tmax = Infinity;

        for (let i = 0; i < 3; i++) {
          if (Math.abs(dir[i]) < 1e-6) {
            if (origin[i] < -size || origin[i] > size) return null;
          } else {
            let t1 = (-size - origin[i]) / dir[i];
            let t2 = (size - origin[i]) / dir[i];
            if (t1 > t2) {
              const temp = t1;
              t1 = t2;
              t2 = temp;
            }
            tmin = Math.max(tmin, t1);
            tmax = Math.min(tmax, t2);
          }
        }

        if (tmax >= tmin && tmax > 0) {
          return { start: Math.max(0, tmin), end: tmax };
        }
        return null;
      }

      function applyDragRotation(state, dx, dy) {
        const sensitivity = ROT_SENS;
        return {
          theta: state.theta - dx * sensitivity,
          phi: state.phi - dy * sensitivity,
        };
      }

      function rgbCss(r, g, b) {
        const to255 = (v) => Math.round(v * 255);
        return `rgb(${to255(r)}, ${to255(g)}, ${to255(b)})`;
      }

      function textColorForFill(fill) {
        const hex = fill.replace("#", "");
        const r = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        return luminance > 160 ? "#000000" : "#ffffff";
      }

      function buildBinaryGraph3D() {
        const nodes = [];
        const edges = [];
        const scale = 1.35;
        const levels = [0, 1];

        for (const r of levels) {
          for (const g of levels) {
            for (const b of levels) {
              const id = `${r}${g}${b}`;
              const x = (r === 0 ? -1 : 1) * scale;
              const y = (g === 0 ? -1 : 1) * scale;
              const z = (b === 0 ? -1 : 1) * scale;
              nodes.push({
                id,
                r,
                g,
                b,
                pos: [x, y, z],
                sum: r + g + b,
                label: labelMapBinary[id],
              });
            }
          }
        }

        for (const a of nodes) {
          for (const b of nodes) {
            const dr = b.r - a.r;
            const dg = b.g - a.g;
            const db = b.b - a.b;
            if (dr >= 0 && dg >= 0 && db >= 0 && dr + dg + db === 1) {
              edges.push([a.id, b.id]);
            }
          }
        }

        assert(nodes.length === 8, "Binary nodes must be 8");
        assert(edges.length === 12, "Binary edges must be 12");
        return { nodes, edges };
      }

      function toCenteredCoord(v) {
        if (v === 0) return -1;
        if (v === 0.5) return 0;
        return 1;
      }

      function buildTernaryGraph() {
        const nodes = [];
        const edges = [];
        const scale = 1.35;
        const levels = [0, 0.5, 1];

        for (const r of levels) {
          for (const g of levels) {
            for (const b of levels) {
              const id = `${r}-${g}-${b}`;
              const x = toCenteredCoord(r) * scale;
              const y = toCenteredCoord(g) * scale;
              const z = toCenteredCoord(b) * scale;
              nodes.push({
                id,
                r,
                g,
                b,
                pos: [x, y, z],
                sum: r + g + b,
              });
            }
          }
        }

        for (const a of nodes) {
          for (const b of nodes) {
            const dr = b.r - a.r;
            const dg = b.g - a.g;
            const db = b.b - a.b;
            const positives = [dr, dg, db].filter((d) => d === 0.5);
            const zeros = [dr, dg, db].filter((d) => d === 0);
            if (positives.length === 1 && zeros.length === 2) {
              edges.push([a.id, b.id]);
            }
          }
        }

        assert(nodes.length === 27, "Ternary nodes must be 27");
        return { nodes, edges };
      }

      const BINARY_3D = buildBinaryGraph3D();
      const TERNARY_3D = buildTernaryGraph();

      function createSVGElement(tag, attrs, text) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (const [k, v] of Object.entries(attrs)) {
          if (v === undefined || v === null) continue;
          el.setAttribute(k, String(v));
        }
        if (text !== undefined) el.textContent = text;
        return el;
      }

      function clear(svg) {
        while (svg.firstChild) svg.removeChild(svg.firstChild);
      }

      function getSize(svg) {
        const rect = svg.getBoundingClientRect();
        const w = Math.max(1, rect.width);
        const h = Math.max(1, rect.height);
        return { w, h };
      }

      function makeLatticeController({
        svg,
        graph,
        autoRotateState,
        showNodesRef,
        showEdgesRef,
        isBinary,
        onFire,
      }) {
        let psi = 0;
        let theta = 0;
        let phi = 0.62;
        let zoom = 1.0;
        let dragging = false;
        const dragState = { active: false, lastX: 0, lastY: 0, startX: 0, startY: 0, pointerId: null };
        const activeBalls = [];

        function setRotation(next) {
          if (typeof next.psi === "number") psi = next.psi;
          if (typeof next.theta === "number") theta = next.theta;
          if (typeof next.phi === "number") phi = next.phi;
        }

        function rotateAuto(dt) {
          if (!dragging) {
            if (autoRotateState.x) phi += dt * AUTO_ROT_SPEED;
            if (autoRotateState.y) theta += dt * AUTO_ROT_SPEED;
            if (autoRotateState.z) psi += dt * AUTO_ROT_SPEED;
          }
        }

        function handleWheel(e) {
          e.preventDefault();
          const next = e.deltaY > 0 ? zoom * 0.92 : zoom * 1.08;
          zoom = clamp(next, ZOOM_MIN, ZOOM_MAX);
        }

        function startDrag(e) {
          if (e.button !== undefined && e.button !== 0) return;
          if (!svg) return;
          svg.setPointerCapture?.(e.pointerId);
          dragState.active = true;
          dragState.lastX = e.clientX;
          dragState.lastY = e.clientY;
          dragState.startX = e.clientX;
          dragState.startY = e.clientY;
          dragState.pointerId = e.pointerId;
          dragging = true;
          svg.style.cursor = "grabbing";
        }

        function moveDrag(e) {
          if (!dragState.active) return;
          const dx = e.clientX - dragState.lastX;
          const dy = e.clientY - dragState.lastY;
          dragState.lastX = e.clientX;
          dragState.lastY = e.clientY;

          const next = applyDragRotation({ theta, phi }, dx, dy);
          theta = next.theta;
          phi = next.phi;
        }

        function endDrag(e) {
          if (!dragState.active) return;
          try {
            svg.releasePointerCapture?.(e.pointerId);
          } catch (_) {
            // ignore
          }

          if (onFire) {
            const dist = Math.hypot(e.clientX - dragState.startX, e.clientY - dragState.startY);
            if (dist < 5) {
              onFire(e.clientX, e.clientY);
            }
          }

          dragState.active = false;
          dragState.pointerId = null;
          dragging = false;
          svg.style.cursor = "grab";
        }

        function fireBall(clientX, clientY) {
          const { w, h } = getSize(svg);
          const rect = svg.getBoundingClientRect();
          const base = Math.min(w, h) * 0.22;
          const scale = base * zoom;

          const cx = clientX - rect.left - w / 2;
          const cy = clientY - rect.top - h / 2;
          const originRot = [cx / scale, -cy / scale, 0];
          const dirRot = [0.85, -0.55, -1];

          const pullBack = 5;
          const pulledOriginRot = [
            originRot[0] - dirRot[0] * pullBack,
            originRot[1] - dirRot[1] * pullBack,
            originRot[2] - dirRot[2] * pullBack,
          ];

          let originM = rotateX(pulledOriginRot, -phi);
          originM = rotateY(originM, -theta);
          originM = rotateZ(originM, -psi);

          let dirM = rotateX(dirRot, -phi);
          dirM = rotateY(dirM, -theta);
          dirM = rotateZ(dirM, -psi);

          const hit = intersectCube(originM, dirM, 1.35);
          if (!hit) return;

          const startP = [
            originM[0] + hit.start * dirM[0],
            originM[1] + hit.start * dirM[1],
            originM[2] + hit.start * dirM[2],
          ];
          const endP = [
            originM[0] + hit.end * dirM[0],
            originM[1] + hit.end * dirM[1],
            originM[2] + hit.end * dirM[2],
          ];

          const axisDir = normalize(dirM);
          let up = [0, 1, 0];
          if (Math.abs(axisDir[1]) > 0.99) up = [1, 0, 0];

          const uBasis = normalize(crossProduct(up, axisDir));
          const vBasis = normalize(crossProduct(axisDir, uBasis));

          activeBalls.push({
            id: Math.random().toString(36).slice(2),
            startP,
            endP,
            uBasis,
            vBasis,
            startTime: performance.now(),
            exitLatched: false,
          });
        }

        function updateBalls(now) {
          if (!activeBalls.length) return;
          for (let i = activeBalls.length - 1; i >= 0; i--) {
            const b = activeBalls[i];
            const tProg = (now - b.startTime) / 12000;

            if (tProg <= 1) continue;

            if (b.exitLatched) {
              const over = tProg - 1;
              const px = b.exitWorldPos[0] + b.exitWorldVel[0] * over;
              const py = b.exitWorldPos[1] + b.exitWorldVel[1] * over;
              const pz = b.exitWorldPos[2] + b.exitWorldVel[2] * over;
              if (px * px + py * py + pz * pz >= 400) {
                activeBalls.splice(i, 1);
              }
              continue;
            }

            if (tProg >= 10) {
              activeBalls.splice(i, 1);
            }
          }
        }

        function draw() {
          const { w, h } = getSize(svg);
          svg.setAttribute("viewBox", `0 0 ${w} ${h}`);

          const posById = {};
          const nodes2d = graph.nodes
            .map((n) => {
              let p = rotateZ(n.pos, psi);
              p = rotateY(p, theta);
              p = rotateX(p, phi);
              const screen = projectIso(p, w, h, zoom);
              posById[n.id] = screen;
              return { ...n, screen };
            })
            .sort((a, b) => a.screen[2] - b.screen[2]);

          const edges2d = graph.edges.map(([a, b]) => {
            const pa = posById[a];
            const pb = posById[b];
            return { a, b, pa, pb };
          });

          clear(svg);

          if (showEdgesRef.value) {
            for (const e of edges2d) {
              if (!e.pa || !e.pb) continue;
              const edgeColor = isBinary ? "#64748b" : "#94a3b8";
              const edgeWidth = isBinary ? "2.5" : "1.5";
              const edgeOpacity = isBinary ? "0.4" : "0.22";
              svg.appendChild(
                createSVGElement("line", {
                  x1: e.pa[0],
                  y1: e.pa[1],
                  x2: e.pb[0],
                  y2: e.pb[1],
                  stroke: edgeColor,
                  strokeWidth: edgeWidth,
                  opacity: edgeOpacity,
                })
              );
            }
          }

          if (showNodesRef.value) {
            for (const n of nodes2d) {
              const [x, y, z] = n.screen;
              const depth = (z + 2.2) / 4.4;
              const depthBoost = 0.45 + 0.65 * clamp(depth, 0, 1);

              const fill = isBinary
                ? colorMapBinary[n.id]
                : rgbCss(n.r, n.g, n.b);

              const isBlackNode = isBinary ? n.id === "000" : n.sum === 0;
              const strokeColor = isBlackNode ? "#ffffff" : isBinary ? "#e2e8f0" : "#0f172a";
              const radius = isBinary ? 30 * zoom : (n.r % 1 === 0 && n.g % 1 === 0 && n.b % 1 === 0 ? 18 * zoom : 9 * zoom);
              const strokeWidth = (isBlackNode ? 3 : (isBinary ? 2 : 1)) * zoom;
              const opacity = isBinary ? (0.75 + 0.25 * depthBoost) * 0.8 : (0.55 + 0.45 * depthBoost) * 0.7;

                const gEl = createSVGElement("g", { opacity: String(opacity) });
              const c = createSVGElement("circle", {
                cx: x,
                cy: y,
                r: radius,
                fill,
                stroke: strokeColor,
                strokeWidth: String(strokeWidth),
                style: isBinary ? "filter: drop-shadow(0px 4px 8px rgba(0,0,0,0.5));" : undefined,
              });
              gEl.appendChild(c);

              if (isBinary) {
                gEl.appendChild(
                  createSVGElement(
                    "text",
                    {
                      x,
                      y,
                      "text-anchor": "middle",
                      "dominant-baseline": "middle",
                      fontSize: String(14 * zoom),
                      fontWeight: "800",
                      fill: textColorForFill(fill),
                    },
                    n.label
                  )
                );
              }

              svg.appendChild(gEl);
            }
          }

          if (!isBinary) {
            const now = performance.now();
            updateBalls(now);

            for (const b of activeBalls) {
              const tProg = (now - b.startTime) / 12000;
              if (tProg < 0) continue;

              if (tProg > 1 && !b.exitLatched) {
                const mVel = [
                  (b.endP[0] - b.startP[0]) - 0.45 * Math.PI * b.uBasis[0],
                  (b.endP[1] - b.startP[1]) - 0.45 * Math.PI * b.uBasis[1],
                  (b.endP[2] - b.startP[2]) - 0.45 * Math.PI * b.uBasis[2],
                ];

                let posRot = rotateZ(b.endP, psi);
                posRot = rotateY(posRot, theta);
                posRot = rotateX(posRot, phi);
                let velRot = rotateZ(mVel, psi);
                velRot = rotateY(velRot, theta);
                velRot = rotateX(velRot, phi);
                b.exitWorldPos = posRot;
                b.exitWorldVel = velRot;
                b.exitLatched = true;
              }

              const NUM_ECHOS = 16;
              const TRAIL_STEP = 0.008;
              const trail = [];

              for (let i = NUM_ECHOS; i >= 0; i--) {
                const t = tProg - i * TRAIL_STEP;
                if (t < 0) continue;

                let pRot;
                let centerDepth;
                let fill;

                if (t <= 1) {
                  const linearX = b.startP[0] + (b.endP[0] - b.startP[0]) * t;
                  const linearY = b.startP[1] + (b.endP[1] - b.startP[1]) * t;
                  const linearZ = b.startP[2] + (b.endP[2] - b.startP[2]) * t;

                  const spiralRadius = 0.45 * Math.sin(Math.PI * t);
                  const angle = 4 * 2 * Math.PI * t;
                  const uOffset = spiralRadius * Math.cos(angle);
                  const vOffset = spiralRadius * Math.sin(angle);

                  const px = linearX + uOffset * b.uBasis[0] + vOffset * b.vBasis[0];
                  const py = linearY + uOffset * b.uBasis[1] + vOffset * b.vBasis[1];
                  const pz = linearZ + uOffset * b.uBasis[2] + vOffset * b.vBasis[2];

                  pRot = rotateZ([px, py, pz], psi);
                  pRot = rotateY(pRot, theta);
                  pRot = rotateX(pRot, phi);

                  let linearForDepth = rotateZ([linearX, linearY, linearZ], psi);
                  linearForDepth = rotateY(linearForDepth, theta);
                  linearForDepth = rotateX(linearForDepth, phi);
                  centerDepth = (linearForDepth[2] + 2.2) / 4.4;

                  const isOutside = px < -1.35 || px > 1.35 || py < -1.35 || py > 1.35 || pz < -1.35 || pz > 1.35;
                  const rVal = clamp((px + 1.35) / 2.7, 0, 1);
                  const gVal = clamp((py + 1.35) / 2.7, 0, 1);
                  const bVal = clamp((pz + 1.35) / 2.7, 0, 1);
                  fill = isOutside ? "#ffffff" : rgbCss(rVal, gVal, bVal);
                } else {
                  const overT = t - 1;
                  pRot = [
                    b.exitWorldPos[0] + b.exitWorldVel[0] * overT,
                    b.exitWorldPos[1] + b.exitWorldVel[1] * overT,
                    b.exitWorldPos[2] + b.exitWorldVel[2] * overT,
                  ];
                  centerDepth = (pRot[2] + 2.2) / 4.4;
                  fill = "#ffffff";
                }

                const [sx, sy] = projectIso(pRot, w, h, zoom);
                const depthScale = 0.1 + 2.4 * clamp(centerDepth, -0.5, 1);
                const isMain = i === 0;
                const radius = 10 * depthScale * zoom;
                const opacity = isMain ? 1 : 0.65 * (1 - i / NUM_ECHOS);

                trail.push(
                  createSVGElement("circle", {
                    cx: sx,
                    cy: sy,
                    r: radius,
                    fill,
                    opacity: String(opacity),
                    stroke: isMain ? "#ffffff" : "none",
                    strokeWidth: String(isMain ? 1.5 * depthScale * zoom : 0),
                  })
                );
              }

              const gEl = createSVGElement("g", {});
              for (const p of trail) gEl.appendChild(p);
              svg.appendChild(gEl);
            }
          }

          svg.appendChild(
            createSVGElement(
              "text",
              {
                x: 18,
                y: 26,
                fontSize: 12,
                fontWeight: 800,
                fill: "#e2e8f0",
              },
              isBinary
                ? "Projected 3D lattice over {0, 1}7"
                : "Projected 3D lattice over {0, 0.5, 1}7"
            )
          );

          svg.appendChild(
            createSVGElement(
              "text",
              {
                x: 18,
                y: 46,
                fontSize: 11,
                fontWeight: 600,
                fill: "#94a3b8",
              },
              isBinary
                ? "Drag to rotate. Wheel to zoom."
                : `Drag to rotate. Wheel to zoom.${showNodesRef.value ? "" : " Click cube to fire ray."}`
            )
          );
        }

        function loop(now) {
          const prev = loop._prevTime || now;
          const dt = (now - prev) / 1000;
          loop._prevTime = now;

          rotateAuto(dt);
          draw();
          requestAnimationFrame(loop);
        }

        const handler = {
          resetView() {
            psi = 0;
            theta = 0;
            phi = 0.62;
            zoom = 1;
          },
        };

        function attachInteractions() {
          svg.addEventListener("pointerdown", startDrag);
          svg.addEventListener("pointermove", moveDrag);
          svg.addEventListener("pointerup", endDrag);
          svg.addEventListener("pointercancel", endDrag);
          svg.addEventListener("pointerleave", endDrag);
          svg.addEventListener("wheel", handleWheel, { passive: false });
          svg.style.cursor = "grab";
        }

        attachInteractions();
        requestAnimationFrame(loop);

        return {
          getState() {
            return { psi, theta, phi, zoom };
          },
          setRotationState(next) {
            setRotation(next);
          },
          resetView: handler.resetView,
          fireBall,
          _update: draw,
        };
      }

      const binaryToggleX = document.getElementById("binary-toggle-x");
      const binaryToggleY = document.getElementById("binary-toggle-y");
      const binaryToggleZ = document.getElementById("binary-toggle-z");
      const binaryToggleNodes = document.getElementById("binary-toggle-nodes");
      const binaryToggleEdges = document.getElementById("binary-toggle-edges");
      const binaryReset = document.getElementById("binary-reset");

      const ternaryToggleX = document.getElementById("ternary-toggle-x");
      const ternaryToggleY = document.getElementById("ternary-toggle-y");
      const ternaryToggleZ = document.getElementById("ternary-toggle-z");
      const ternaryToggleNodes = document.getElementById("ternary-toggle-nodes");
      const ternaryToggleEdges = document.getElementById("ternary-toggle-edges");
      const ternaryReset = document.getElementById("ternary-reset");

      const binaryRef = { current: null };
      const ternaryRef = { current: null };

      const binaryState = {
        autoRotate: { x: false, y: true, z: false },
        showNodes: { value: true },
        showEdges: { value: true },
      };

      const ternaryState = {
        autoRotate: { x: false, y: true, z: false },
        showNodes: { value: true },
        showEdges: { value: true },
      };

      const binaryController = makeLatticeController({
        svg: document.getElementById("binarySvg"),
        graph: BINARY_3D,
        autoRotateState: binaryState.autoRotate,
        showNodesRef: binaryState.showNodes,
        showEdgesRef: binaryState.showEdges,
        isBinary: true,
        onFire: null,
      });

      const ternaryController = makeLatticeController({
        svg: document.getElementById("ternarySvg"),
        graph: TERNARY_3D,
        autoRotateState: ternaryState.autoRotate,
        showNodesRef: ternaryState.showNodes,
        showEdgesRef: ternaryState.showEdges,
        isBinary: false,
        onFire: (x, y) => ternaryController.fireBall(x, y),
      });

      binaryRef.current = binaryController;
      ternaryRef.current = ternaryController;

      function syncButton(btn, active, activeClass = "active") {
        btn.classList.toggle(activeClass, active);
      }

      function syncBinaryButtons() {
        syncButton(binaryToggleX, binaryState.autoRotate.x);
        syncButton(binaryToggleY, binaryState.autoRotate.y);
        syncButton(binaryToggleZ, binaryState.autoRotate.z);
        syncButton(binaryToggleNodes, binaryState.showNodes.value, "visible");
        syncButton(binaryToggleEdges, binaryState.showEdges.value, "visible");
      }

      function syncTernaryButtons() {
        syncButton(ternaryToggleX, ternaryState.autoRotate.x);
        syncButton(ternaryToggleY, ternaryState.autoRotate.y);
        syncButton(ternaryToggleZ, ternaryState.autoRotate.z);
        syncButton(ternaryToggleNodes, ternaryState.showNodes.value, "visible");
        syncButton(ternaryToggleEdges, ternaryState.showEdges.value, "visible");
      }

      binaryToggleX.addEventListener("click", () => {
        binaryState.autoRotate.x = !binaryState.autoRotate.x;
        syncBinaryButtons();
      });

      binaryToggleY.addEventListener("click", () => {
        binaryState.autoRotate.y = !binaryState.autoRotate.y;
        syncBinaryButtons();
      });

      binaryToggleZ.addEventListener("click", () => {
        binaryState.autoRotate.z = !binaryState.autoRotate.z;
        syncBinaryButtons();
      });

      binaryToggleNodes.addEventListener("click", () => {
        binaryState.showNodes.value = !binaryState.showNodes.value;
        syncBinaryButtons();
      });

      binaryToggleEdges.addEventListener("click", () => {
        binaryState.showEdges.value = !binaryState.showEdges.value;
        syncBinaryButtons();
      });

      ternaryToggleX.addEventListener("click", () => {
        ternaryState.autoRotate.x = !ternaryState.autoRotate.x;
        syncTernaryButtons();
      });

      ternaryToggleY.addEventListener("click", () => {
        ternaryState.autoRotate.y = !ternaryState.autoRotate.y;
        syncTernaryButtons();
      });

      ternaryToggleZ.addEventListener("click", () => {
        ternaryState.autoRotate.z = !ternaryState.autoRotate.z;
        syncTernaryButtons();
      });

      ternaryToggleNodes.addEventListener("click", () => {
        ternaryState.showNodes.value = !ternaryState.showNodes.value;
        syncTernaryButtons();
      });

      ternaryToggleEdges.addEventListener("click", () => {
        ternaryState.showEdges.value = !ternaryState.showEdges.value;
        syncTernaryButtons();
      });

      binaryReset.addEventListener("click", () => {
        binaryRef.current?.resetView();
      });

      ternaryReset.addEventListener("click", () => {
        ternaryRef.current?.resetView();
      });

      syncBinaryButtons();
      syncTernaryButtons();
    })();
  </script>
</body>
</html>
